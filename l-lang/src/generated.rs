// generated by lelwel 0.6.2

use crate::parser::{Context, CstIndex, Diagnostic, Span, Token};

use codespan_reporting::diagnostic::Label;

// TODO: change err macro if codespan_reporting is not used
macro_rules! err {
    [$span:expr, $($tk:literal),*] => {
        Diagnostic::error()
            .with_message(syntax_error_message!($span, $($tk),*))
            .with_labels(vec![Label::primary((), $span.start as usize..$span.end as usize)])
    }
}

#[allow(unused_macros)]
macro_rules! syntax_error_message {
    [$span:expr, $($tk:literal),*] => {
        {
            let expected = [$($tk),*];
            let mut msg = "invalid syntax, expected".to_string();
            if expected.len() > 1 {
                msg.push_str(" one of: ");
            } else {
                msg.push_str(": ");
            }
            let mut count = 0;
            for e in expected {
                count += 1;
                let s = format!("{}", e);
                let s = if s.starts_with('<') && s.ends_with('>') && s.len() > 2 {
                    s
                } else {
                    format!("'{}'", s)
                };
                msg.push_str(&s);
                if count < expected.len() {
                    msg.push_str(", ");
                }
            }
            msg
        }
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[allow(dead_code)]
pub enum Rule {
    Error,
    File,
    Fn,
    ParamList,
    Params,
    Param,
    ReturnType,
    TypeExpr,
    Block,
    Struct,
    StructField,
    Stmt,
    StmtExpr,
    StmtLet,
    StmtReturn,
    StmtIf,
    Alter,
    Consequent,
    Expr,
    Factor,
    Prime,
    ExprCall,
    StructConstructor,
    StructConstructorField,
    ArgList,
    Arguments,
    ExprLiteral,
    ExprName,
    MemberExpr,
    ExprParen,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]
pub struct NodeRef(pub CstIndex);

impl NodeRef {
    #[allow(dead_code)]
    pub const ROOT: NodeRef = NodeRef(0);
}

#[derive(Debug, Copy, Clone)]
pub enum Node {
    Rule(Rule, CstIndex),
    Token(CstIndex),
}

#[derive(Clone, Copy)]
struct MarkOpened(CstIndex);
#[derive(Clone, Copy)]
struct MarkClosed(CstIndex);

pub struct CstChildren<'a> {
    iter: std::slice::Iter<'a, Node>,
    offset: CstIndex,
}
#[allow(clippy::unnecessary_cast)]
impl<'a> Iterator for CstChildren<'a> {
    type Item = NodeRef;

    fn next(&mut self) -> Option<Self::Item> {
        let offset = self.offset;
        let node = self.iter.next();
        self.offset += 1;
        if let Some(Node::Rule(_, end_offset)) = node {
            if *end_offset > 0 {
                self.iter.nth((*end_offset as usize).saturating_sub(1));
                self.offset += *end_offset;
            }
        }
        if node.is_some() {
            Some(NodeRef(offset))
        } else {
            None
        }
    }
}

pub struct Cst<'a> {
    pub source: &'a str,
    pub tokens: Vec<Token>,
    ranges: Vec<std::ops::Range<CstIndex>>,
    pub nodes: Vec<Node>,
    token_count: CstIndex,
}
#[allow(clippy::unnecessary_cast, dead_code)]
impl<'a> Cst<'a> {
    fn new(source: &'a str, tokens: Vec<Token>, ranges: Vec<std::ops::Range<CstIndex>>) -> Self {
        Self {
            source,
            tokens,
            ranges,
            nodes: vec![],
            token_count: 0,
        }
    }
    fn open(&mut self) -> MarkOpened {
        let mark = MarkOpened(self.nodes.len() as CstIndex);
        self.nodes.push(Node::Rule(Rule::Error, 0));
        mark
    }
    fn close(&mut self, mark: MarkOpened, rule: Rule) -> MarkClosed {
        self.nodes[mark.0 as usize] = Node::Rule(rule, self.nodes.len() as CstIndex - 1 - mark.0);
        MarkClosed(mark.0)
    }
    fn advance(&mut self) {
        self.nodes.push(Node::Token(self.token_count));
        self.token_count += 1;
    }
    fn open_before(&mut self, mark: MarkClosed) -> MarkOpened {
        self.nodes
            .insert(mark.0 as usize, Node::Rule(Rule::Error, 0));
        MarkOpened(mark.0)
    }
    fn mark(&self) -> MarkClosed {
        MarkClosed(self.nodes.len() as CstIndex)
    }
    pub fn children(&self, node: NodeRef) -> CstChildren {
        let iter = if let Some(Node::Rule(_, end_offset)) = self.nodes.get(node.0 as usize) {
            self.nodes[node.0 as usize + 1..node.0 as usize + *end_offset as usize + 1].iter()
        } else {
            std::slice::Iter::default()
        };
        CstChildren {
            iter,
            offset: node.0 + 1,
        }
    }
    pub fn get(&self, node: NodeRef) -> Node {
        self.nodes[node.0 as usize]
    }

    pub fn get_span(&self, node: NodeRef) -> Option<Span> {
        match self.nodes.get(node.0 as usize) {
            Some(Node::Token(idx)) => {
                let range = &self.ranges[*idx as usize];
                Some(range.start as usize..range.end as usize)
            }
            Some(Node::Rule(_, _)) => self
                .children(node)
                .filter(|node_ref| {
                    if let Node::Token(idx) = self.get(*node_ref) {
                        !matches!(self.tokens[idx as usize], Token::Error | Token::Whitespace)
                    } else {
                        true
                    }
                })
                .filter_map(|n| self.get_span(n))
                .reduce(|acc, e| acc.start.min(e.start)..acc.end.max(e.end)),
            None => None,
        }
    }
    pub fn get_token(&self, node: NodeRef, token: Token) -> Option<(&'a str, Span)> {
        if let Some(Node::Token(idx)) = self.nodes.get(node.0 as usize) {
            let tok = self.tokens[*idx as usize];
            let range = &self.ranges[*idx as usize];
            if token == tok {
                let span = range.start as usize..range.end as usize;
                Some((&self.source[span.clone()], span))
            } else {
                None
            }
        } else {
            None
        }
    }
    pub fn get_rule(&self, node: NodeRef, rule: Rule) -> Option<NodeRef> {
        if let Some(Node::Rule(r, _)) = self.nodes.get(node.0 as usize) {
            if rule == *r {
                Some(node)
            } else {
                None
            }
        } else {
            None
        }
    }
}

#[allow(clippy::unnecessary_cast)]
impl std::fmt::Display for Cst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        const DEPTH: &str = "    ";
        fn rec(
            cst: &Cst,
            f: &mut std::fmt::Formatter<'_>,
            idx: NodeRef,
            indent: usize,
        ) -> std::fmt::Result {
            match cst.get(idx) {
                Node::Rule(rule, _) => {
                    if let Some(range) = cst.get_span(idx) {
                        writeln!(f, "{}{rule:?} [{range:?}]", DEPTH.repeat(indent),)?;
                    } else {
                        writeln!(f, "{}{rule:?}", DEPTH.repeat(indent),)?;
                    }
                }
                Node::Token(tok) => {
                    let range = &cst.ranges[tok as usize];
                    writeln!(
                        f,
                        "{}{:?} {:?} [{:?}]",
                        DEPTH.repeat(indent),
                        cst.tokens[tok as usize],
                        &cst.source[range.start as usize..range.end as usize],
                        range,
                    )?;
                }
            }
            for c in cst.children(idx) {
                rec(cst, f, c, indent + 1)?;
            }
            Ok(())
        }
        rec(self, f, NodeRef(0), 0)
    }
}

macro_rules! expect {
    ($tok:ident, $sym:literal, $self:expr, $diags:expr) => {
        if let Token::$tok = $self.current {
            $self.advance(false);
        } else {
            $self.error($diags, err![$self.span(), $sym]);
        }
    };
}

pub struct Parser<'a> {
    cst: Cst<'a>,
    pos: usize,
    current: Token,
    error_cooldown: bool,
    max_offset: usize,
    #[allow(dead_code)]
    context: Context<'a>,
}
#[allow(clippy::while_let_loop, dead_code)]
impl<'a> Parser<'a> {
    fn error(&self, diags: &mut Vec<Diagnostic>, diag: Diagnostic) {
        if self.error_cooldown {
            return;
        }
        if let Some(last) = diags.last() {
            if last.labels.first().unwrap().range == diag.labels.first().unwrap().range {
                return;
            }
        }
        diags.push(diag);
    }
    fn advance(&mut self, error: bool) {
        if !error {
            self.error_cooldown = false;
        }
        loop {
            self.pos += 1;
            match self.cst.tokens.get(self.pos) {
                Some(Token::Error | Token::Whitespace) => {
                    self.cst.advance();
                    continue;
                }
                Some(tok) => {
                    self.current = *tok;
                    self.cst.advance();
                    break;
                }
                None => {
                    self.current = Token::EOF;
                    self.cst.advance();
                    break;
                }
            }
        }
    }
    fn is_skipped(token: Token) -> bool {
        matches!(token, Token::Error | Token::Whitespace)
    }
    fn init_skip(&mut self) {
        loop {
            match self.cst.tokens.get(self.pos) {
                Some(Token::Error | Token::Whitespace) => {
                    self.pos += 1;
                    self.cst.advance();
                    continue;
                }
                Some(tok) => {
                    self.current = *tok;
                    break;
                }
                None => {
                    self.current = Token::EOF;
                    break;
                }
            }
        }
    }
    fn advance_with_error(&mut self, diags: &mut Vec<Diagnostic>, diag: Diagnostic) {
        let m = self.cst.open();
        self.error(diags, diag);
        self.error_cooldown = true;
        self.advance(true);
        self.close(m, Rule::Error, diags);
    }
    #[allow(dead_code)]
    pub fn peek(&self, lookahead: usize) -> Token {
        self.cst
            .tokens
            .iter()
            .skip(self.pos)
            .filter(|token| !Self::is_skipped(**token))
            .nth(lookahead)
            .map_or(Token::EOF, |it| *it)
    }
    fn span(&self) -> std::ops::Range<CstIndex> {
        self.cst
            .ranges
            .get(self.pos)
            .map_or(self.max_offset..self.max_offset, |span| span.clone())
    }
    fn close(&mut self, mark: MarkOpened, rule: Rule, diags: &mut Vec<Diagnostic>) -> MarkClosed {
        let m = self.cst.close(mark, rule);
        self.build(rule, NodeRef(m.0), diags);
        m
    }
    pub fn parse(
        source: &'a str,
        tokens: Vec<Token>,
        ranges: Vec<std::ops::Range<CstIndex>>,
        diags: &mut Vec<Diagnostic>,
    ) -> Cst<'a> {
        let max_offset = source.len();
        let mut parser = Self {
            current: Token::EOF,
            cst: Cst::new(source, tokens, ranges),
            pos: 0,
            error_cooldown: false,
            max_offset,
            context: Context::default(),
        };
        parser.file(diags);
        parser.cst
    }
    fn r#file(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        self.init_skip();
        loop {
            match self.current {
                Token::Fn | Token::Struct => match self.current {
                    Token::Fn => {
                        self.r#fn(diags);
                    }
                    Token::Struct => {
                        self.r#struct(diags);
                    }
                    _ => {
                        self.error(diags, err![self.span(), "fn", "struct"]);
                    }
                },
                Token::EOF => break,
                _ => {
                    self.advance_with_error(
                        diags,
                        err![self.span(), "<end of file>", "fn", "struct"],
                    );
                }
            }
        }
        if self.current != Token::EOF {
            self.error(diags, err![self.span(), "<end of file>"]);
            let error_tree = self.cst.open();
            loop {
                match self.cst.tokens.get(self.pos) {
                    None => break,
                    _ => self.cst.advance(),
                }
                self.pos += 1;
            }
            self.close(error_tree, Rule::Error, diags);
        }
        self.close(m, Rule::File, diags);
    }
    fn r#fn(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Fn, "fn", self, diags);
        expect!(Name, "<name>", self, diags);
        self.r#param_list(diags);
        match self.current {
            Token::Arrow => {
                self.r#return_type(diags);
            }
            Token::LBrace => {}
            _ => {
                self.error(diags, err![self.span(), "->", "{"]);
            }
        }
        self.r#block(diags);
        self.close(m, Rule::Fn, diags);
    }
    fn r#param_list(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(LPar, "(", self, diags);
        match self.current {
            Token::Name => {
                self.r#params(diags);
            }
            Token::RPar => {}
            _ => {
                self.error(diags, err![self.span(), "<name>", ")"]);
            }
        }
        expect!(RPar, ")", self, diags);
        self.close(m, Rule::ParamList, diags);
    }
    fn r#params(&mut self, diags: &mut Vec<Diagnostic>) {
        let lhs = self.cst.mark();
        let mut m = None;
        self.r#param(diags);
        loop {
            match self.current {
                Token::Comma if self.predicate_params_1() => {
                    if m.is_none() {
                        m = Some(self.cst.open_before(lhs));
                    }
                    expect!(Comma, ",", self, diags);
                    self.r#param(diags);
                }
                Token::Comma
                | Token::RPar
                | Token::Arrow
                | Token::EOF
                | Token::Fn
                | Token::LBrace
                | Token::Struct => break,
                _ => {
                    self.advance_with_error(diags, err![self.span(), ",", ")"]);
                }
            }
        }
        match self.current {
            Token::Comma => {
                if m.is_none() {
                    m = Some(self.cst.open_before(lhs));
                }
                expect!(Comma, ",", self, diags);
            }
            Token::RPar => {}
            _ => {
                self.error(diags, err![self.span(), ",", ")"]);
            }
        }
        if let Some(m) = m {
            self.close(m, Rule::Params, diags);
        }
    }
    fn r#param(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Name, "<name>", self, diags);
        expect!(Colon, ":", self, diags);
        self.r#type_expr(diags);
        self.close(m, Rule::Param, diags);
    }
    fn r#return_type(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Arrow, "->", self, diags);
        self.r#type_expr(diags);
        self.close(m, Rule::ReturnType, diags);
    }
    fn r#type_expr(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        match self.current {
            Token::Usize => {
                expect!(Usize, "usize", self, diags);
            }
            Token::Boolean => {
                expect!(Boolean, "bool", self, diags);
            }
            _ => {
                self.error(diags, err![self.span(), "bool", "usize"]);
            }
        }
        self.close(m, Rule::TypeExpr, diags);
    }
    fn r#block(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(LBrace, "{", self, diags);
        loop {
            match self.current {
                Token::False
                | Token::If
                | Token::Int
                | Token::LBrace
                | Token::LPar
                | Token::Let
                | Token::Name
                | Token::Return
                | Token::True => {
                    self.r#stmt(diags);
                }
                Token::RBrace
                | Token::EOF
                | Token::Else
                | Token::Fn
                | Token::Semi
                | Token::Struct => break,
                _ => {
                    self.advance_with_error(
                        diags,
                        err![
                            self.span(),
                            "false",
                            "if",
                            "<int>",
                            "{",
                            "(",
                            "let",
                            "<name>",
                            "}",
                            "return",
                            "true"
                        ],
                    );
                }
            }
        }
        expect!(RBrace, "}", self, diags);
        self.close(m, Rule::Block, diags);
    }
    fn r#struct(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Struct, "struct", self, diags);
        expect!(Name, "<name>", self, diags);
        expect!(LBrace, "{", self, diags);
        self.r#struct_field(diags);
        loop {
            match self.current {
                Token::Comma => {
                    expect!(Comma, ",", self, diags);
                    self.r#struct_field(diags);
                }
                Token::RBrace | Token::EOF | Token::Fn | Token::Struct => break,
                _ => {
                    self.advance_with_error(diags, err![self.span(), ",", "}"]);
                }
            }
        }
        expect!(RBrace, "}", self, diags);
        self.close(m, Rule::Struct, diags);
    }
    fn r#struct_field(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Name, "<name>", self, diags);
        expect!(Colon, ":", self, diags);
        self.r#type_expr(diags);
        self.close(m, Rule::StructField, diags);
    }
    fn r#stmt(&mut self, diags: &mut Vec<Diagnostic>) {
        match self.current {
            Token::False | Token::Int | Token::LPar | Token::Name | Token::True => {
                self.r#stmt_expr(diags);
            }
            Token::Let => {
                self.r#stmt_let(diags);
            }
            Token::LBrace => {
                self.r#block(diags);
            }
            Token::Return => {
                self.r#stmt_return(diags);
            }
            Token::If => {
                self.r#stmt_if(diags);
            }
            _ => {
                self.error(
                    diags,
                    err![
                        self.span(),
                        "false",
                        "if",
                        "<int>",
                        "{",
                        "(",
                        "let",
                        "<name>",
                        "return",
                        "true"
                    ],
                );
            }
        }
    }
    fn r#stmt_expr(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        self.r#expr(diags);
        expect!(Semi, ";", self, diags);
        self.close(m, Rule::StmtExpr, diags);
    }
    fn r#stmt_let(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Let, "let", self, diags);
        expect!(Name, "<name>", self, diags);
        expect!(Asn, "=", self, diags);
        self.r#expr(diags);
        expect!(Semi, ";", self, diags);
        self.close(m, Rule::StmtLet, diags);
    }
    fn r#stmt_return(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Return, "return", self, diags);
        match self.current {
            Token::False | Token::Int | Token::LPar | Token::Name | Token::True => {
                self.r#expr(diags);
            }
            Token::Semi => {}
            _ => {
                self.error(
                    diags,
                    err![self.span(), "false", "<int>", "(", "<name>", ";", "true"],
                );
            }
        }
        expect!(Semi, ";", self, diags);
        self.close(m, Rule::StmtReturn, diags);
    }
    fn r#stmt_if(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(If, "if", self, diags);
        expect!(LPar, "(", self, diags);
        self.r#expr(diags);
        expect!(RPar, ")", self, diags);
        self.r#block(diags);
        loop {
            match self.current {
                Token::Else if self.predicate_stmt_if_1() => {
                    self.r#alter(diags);
                }
                Token::Else
                | Token::Semi
                | Token::EOF
                | Token::False
                | Token::Fn
                | Token::If
                | Token::Int
                | Token::LBrace
                | Token::LPar
                | Token::Let
                | Token::Name
                | Token::RBrace
                | Token::Return
                | Token::Struct
                | Token::True => break,
                _ => {
                    self.advance_with_error(diags, err![self.span(), "else", ";"]);
                }
            }
        }
        match self.current {
            Token::Else => {
                self.r#consequent(diags);
            }
            Token::Semi => {}
            _ => {
                self.error(diags, err![self.span(), "else", ";"]);
            }
        }
        expect!(Semi, ";", self, diags);
        self.close(m, Rule::StmtIf, diags);
    }
    fn r#alter(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Else, "else", self, diags);
        expect!(If, "if", self, diags);
        expect!(LPar, "(", self, diags);
        self.r#expr(diags);
        expect!(RPar, ")", self, diags);
        self.r#block(diags);
        self.close(m, Rule::Alter, diags);
    }
    fn r#consequent(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Else, "else", self, diags);
        self.r#block(diags);
        self.close(m, Rule::Consequent, diags);
    }
    fn r#expr(&mut self, diags: &mut Vec<Diagnostic>) {
        match self.current {
            Token::Name if self.predicate_expr_1() => {
                self.r#member_expr(diags);
            }
            Token::Name if self.predicate_expr_2() => {
                self.r#struct_constructor(diags);
            }
            Token::False | Token::Int | Token::LPar | Token::Name | Token::True
                if self.predicate_expr_3() =>
            {
                self.r#factor(diags);
            }
            Token::Name if self.predicate_expr_4() => {
                self.r#expr_call(diags);
            }
            Token::Name => {
                self.r#expr_name(diags);
            }
            Token::False | Token::Int | Token::True => {
                self.r#expr_literal(diags);
            }
            Token::LPar => {
                self.r#expr_paren(diags);
            }
            _ => {
                self.error(
                    diags,
                    err![self.span(), "false", "<int>", "(", "<name>", "true"],
                );
            }
        }
    }
    fn r#factor(&mut self, diags: &mut Vec<Diagnostic>) {
        let lhs = self.cst.mark();
        fn rec(
            parser: &mut Parser,
            diags: &mut Vec<Diagnostic>,
            min_prec: usize,
            mut lhs: MarkClosed,
        ) {
            loop {
                let prec = match parser.current {
                    Token::Slash | Token::Star => 0,
                    _ => return,
                };
                if prec < min_prec {
                    return;
                }
                parser.advance(false);
                let m = parser.cst.open_before(lhs);
                let rhs = parser.cst.mark();
                parser.prime(diags);
                loop {
                    let (next_prec, left_assoc) = match parser.current {
                        Token::Slash => (0, true),
                        Token::Star => (0, true),
                        _ => break,
                    };
                    if !(prec < next_prec || (!left_assoc && prec == next_prec)) {
                        break;
                    }
                    rec(
                        parser,
                        diags,
                        prec + if next_prec > prec { 1 } else { 0 },
                        rhs,
                    );
                }
                lhs = parser.close(m, Rule::Factor, diags);
            }
        }
        self.prime(diags);
        rec(self, diags, 0, lhs);
    }
    fn r#prime(&mut self, diags: &mut Vec<Diagnostic>) {
        let mut lhs = self.cst.mark();
        match self.current {
            Token::LPar => {
                self.r#expr_paren(diags);
            }
            Token::False | Token::Int | Token::True => {
                self.r#expr_literal(diags);
            }
            Token::Name if self.predicate_prime_1() => {
                let m = self.cst.open();
                self.r#member_expr(diags);
                self.close(m, Rule::Prime, diags);
            }
            Token::Name if self.predicate_prime_2() => {
                let m = self.cst.open();
                self.r#expr_call(diags);
                self.close(m, Rule::Prime, diags);
            }
            Token::Name => {
                self.r#expr_name(diags);
            }
            _ => {
                self.error(
                    diags,
                    err![self.span(), "false", "<int>", "(", "<name>", "true"],
                );
            }
        }
        loop {
            match self.current {
                Token::Minus | Token::Plus => {
                    let m = self.cst.open_before(lhs);
                    match self.current {
                        Token::Plus => {
                            expect!(Plus, "+", self, diags);
                        }
                        Token::Minus => {
                            expect!(Minus, "-", self, diags);
                        }
                        _ => {
                            self.error(diags, err![self.span(), "-", "+"]);
                        }
                    }
                    self.r#prime(diags);
                    lhs = self.close(m, Rule::Prime, diags);
                }
                _ => {
                    break;
                }
            }
        }
    }
    fn r#expr_call(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Name, "<name>", self, diags);
        self.r#arg_list(diags);
        self.close(m, Rule::ExprCall, diags);
    }
    fn r#struct_constructor(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Name, "<name>", self, diags);
        expect!(LBrace, "{", self, diags);
        self.r#struct_constructor_field(diags);
        loop {
            match self.current {
                Token::Comma => {
                    expect!(Comma, ",", self, diags);
                    self.r#struct_constructor_field(diags);
                }
                Token::RBrace
                | Token::EOF
                | Token::Else
                | Token::False
                | Token::Fn
                | Token::If
                | Token::Int
                | Token::LBrace
                | Token::LPar
                | Token::Let
                | Token::Name
                | Token::RPar
                | Token::Return
                | Token::Semi
                | Token::Struct
                | Token::True => break,
                _ => {
                    self.advance_with_error(diags, err![self.span(), ",", "}"]);
                }
            }
        }
        expect!(RBrace, "}", self, diags);
        self.close(m, Rule::StructConstructor, diags);
    }
    fn r#struct_constructor_field(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Name, "<name>", self, diags);
        expect!(Colon, ":", self, diags);
        self.r#expr_literal(diags);
        self.close(m, Rule::StructConstructorField, diags);
    }
    fn r#arg_list(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(LPar, "(", self, diags);
        match self.current {
            Token::False | Token::Int | Token::LPar | Token::Name | Token::True => {
                self.r#arguments(diags);
            }
            Token::RPar => {}
            _ => {
                self.error(
                    diags,
                    err![self.span(), "false", "<int>", "(", "<name>", ")", "true"],
                );
            }
        }
        expect!(RPar, ")", self, diags);
        self.close(m, Rule::ArgList, diags);
    }
    fn r#arguments(&mut self, diags: &mut Vec<Diagnostic>) {
        let lhs = self.cst.mark();
        let mut m = None;
        self.r#expr(diags);
        loop {
            match self.current {
                Token::Comma => {
                    if m.is_none() {
                        m = Some(self.cst.open_before(lhs));
                    }
                    expect!(Comma, ",", self, diags);
                    self.r#expr(diags);
                }
                Token::RPar
                | Token::EOF
                | Token::Else
                | Token::False
                | Token::Fn
                | Token::If
                | Token::Int
                | Token::LBrace
                | Token::LPar
                | Token::Let
                | Token::Minus
                | Token::Name
                | Token::Plus
                | Token::RBrace
                | Token::Return
                | Token::Semi
                | Token::Slash
                | Token::Star
                | Token::Struct
                | Token::True => break,
                _ => {
                    self.advance_with_error(diags, err![self.span(), ",", ")"]);
                }
            }
        }
        if let Some(m) = m {
            self.close(m, Rule::Arguments, diags);
        }
    }
    fn r#expr_literal(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        match self.current {
            Token::Int => {
                expect!(Int, "<int>", self, diags);
            }
            Token::True => {
                expect!(True, "true", self, diags);
            }
            Token::False => {
                expect!(False, "false", self, diags);
            }
            _ => {
                self.error(diags, err![self.span(), "false", "<int>", "true"]);
            }
        }
        self.close(m, Rule::ExprLiteral, diags);
    }
    fn r#expr_name(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(Name, "<name>", self, diags);
        self.close(m, Rule::ExprName, diags);
    }
    fn r#member_expr(&mut self, diags: &mut Vec<Diagnostic>) {
        let mut lhs = self.cst.mark();
        match self.current {
            Token::Name => {
                let m = self.cst.open();
                expect!(Name, "<name>", self, diags);
                self.close(m, Rule::MemberExpr, diags);
            }
            _ => {
                self.error(diags, err![self.span(), "<name>"]);
            }
        }
        loop {
            match self.current {
                Token::Dot => {
                    let m = self.cst.open_before(lhs);
                    expect!(Dot, ".", self, diags);
                    expect!(Name, "<name>", self, diags);
                    lhs = self.close(m, Rule::MemberExpr, diags);
                }
                _ => {
                    break;
                }
            }
        }
    }
    fn r#expr_paren(&mut self, diags: &mut Vec<Diagnostic>) {
        let m = self.cst.open();
        expect!(LPar, "(", self, diags);
        self.r#expr(diags);
        expect!(RPar, ")", self, diags);
        self.close(m, Rule::ExprParen, diags);
    }
}

pub trait PredicatesAndActions {
    /// Called when a new syntax tree node is created
    #[allow(clippy::ptr_arg)]
    fn build(&mut self, _rule: Rule, _node: NodeRef, _diags: &mut Vec<Diagnostic>) {}
    fn predicate_params_1(&self) -> bool;
    fn predicate_stmt_if_1(&self) -> bool;
    fn predicate_expr_1(&self) -> bool;
    fn predicate_expr_2(&self) -> bool;
    fn predicate_expr_3(&self) -> bool;
    fn predicate_expr_4(&self) -> bool;
    fn predicate_prime_1(&self) -> bool;
    fn predicate_prime_2(&self) -> bool;
}

impl<'a> PredicatesAndActions for Parser<'a> {
    fn predicate_params_1(&self) -> bool {
        self.peek(1) != Token::RPar
    }

    fn predicate_expr_1(&self) -> bool {
        self.peek(1) == Token::Dot
    }

    fn predicate_expr_2(&self) -> bool {
        self.peek(1) == Token::LBrace
    }

    fn predicate_expr_3(&self) -> bool {
        matches!(
            self.peek(1),
            Token::Star | Token::Minus | Token::Plus | Token::Slash
        )
    }

    fn predicate_expr_4(&self) -> bool {
        matches!(self.peek(1), Token::LPar)
    }

    fn predicate_prime_1(&self) -> bool {
        matches!(self.peek(1), Token::Dot)
    }

    fn predicate_prime_2(&self) -> bool {
        matches!(self.peek(1), Token::LPar)
    }

    fn predicate_stmt_if_1(&self) -> bool {
        matches!(self.peek(1), Token::If)
    }
}
